---
layout: page
title: "ソフトウェア工学　2025"
permalink: /docs/softwareEng2025
---

# ソフトウェア工学のまとめ
## 第1回
### 本講義の到達目標

ソフトウェア・エンジニアリングの基礎知識の理解および実務的なスキルの習得を目標とする

### 講義の狙い

ソフトウェア工学の知見を考える機会提供


ソフトウェア工学の難しいところは主に3点あげられる。1つは実務から体系化された知見であることである。ソフトウェア開発に携わった経験がないとイメージが沸かない。次に2つ目は知見と実践の乖離である。知見を理解しても実践することが難しい。最後に3つ目は個々人のソフトウェア工学の知識だけでは不十分でチーム全体で共有する必要があるところにある。

## 第2回
ソフトウェアとは「情報を」扱うプロダクトそのもの、プロダクトを提供する手段である。

### ソフトウェアの定義

1.実行されることによって必要な特性、機能、性能を提供する命令語群（コンピュータプログラム） 

2.プログラムが適切に情報を扱うことを可能とするデータ構造

3.プログラムの操作や使用法を記述した情報 

とされている。

ソフトウェアの特徴として、新しい環境やニーズを満たすように適応させる必要があること、新しいビジネス要求を実現するために強化されなければならないこと、より近代的なシステムやデータベースと相互運用するため拡張される必要があること、進化し続ける環境で実行可能となるよう、再構築されなければならないなどがある。

ソフトウェア工学とは「品質」、「コスト」、「納期」の最適なバランスを実現するための手法・方法論のことである。ソフトウェアなしでは社会はまわらない。そのソフトウェアを効率よく開発し、メンテナンスする必要がある。効率と品質の両方、またその人材が求められたり、不測の事態に対応した事業・サービスの継続が求めらている。これらについて考えるソフトウェア工学という分野は社会に必要不可欠である。

## 第3回
ソフトウェアはニーズの発生から、企画・計画、要件定義、開発、実稼働、保守運用、サービス終了、リニューアルといったライフサイクルをたどる。要件定義では、システムの目的や概要、機能、目標性能、開発スケジュールなどを決める。実現する機能・実現しない機能を明確にする段階である。要件定義の意義としてプロジェクト関係者のバイブル、社内外への宣言と協力依頼、RFPなどが挙げられる。要件定義書のあとは設計に移る。コーディングが出来るレベルの仕様書に落とし込む。設計書が書けたらそれに従ってシステム構築に移る。バグのないソフトウェアは存在しないと考えるべきなのでテストとデバッグは必須である。早期のバグ発見・対処が理想であるがすべてをテストすることは不可能であるためどの箇所をどの程度テストするのか考える必要がある。最後に運用・保守に移る。稼働後のデータをプロアクティブに活用するべきであるためこの部分はしっかり考えなければならない。

## 第4回
プロジェクトには有期性と独自性がある。有期性は必ず終わりがある類の仕事で独自性は独自の目的を達成する類の仕事で例としてソフトウェア開発が挙げられる。よりよいソフトウェアを作るためにソフトウェアの分析をする必要がある。ソフトウェアの評価＝価値を測ることであり、コードの物量（ステップ数やオブジェクトの容量）、ファンクションポイント(FP)法、使い勝手(画面の視認性や操作性など)などの評価方法がある。ファンクションポイント法は必要な機能が見えてきた段階でシステム規模を概算することが出来る。投資意思決定の指標にも利用できる。

ソフトウェアの開発にはいくつかのプロセスがある。一つは、ウォーターホール型開発プロセスで進捗管理が容易で、成果物が明確であるというメリットがあるが、後工程にしわ寄せが集中するというリスクがある。次に反復型開発プロセスがある。これはソフトウェアを機能分割し、積み上げ方式で開発していく。部分的に完成させていくので顧客の要求を取り入れやすいが分割のための作業や管理業務が増えるし全体像が見えづらいというデメリットがある。最後に、アジャイルプロセスがある。変化に対応して無駄を廃し、最適な手法で動くソフトウェアの提供を優先する。テスト駆動型開発でウォーターホール型開発プロセスでは想定されていなかった「できるだけ決定を遅らせる」、「できるだけ早く提供を遅らせる」を実現できる。他にも、リスク駆動型開発プロセスも存在する。

## 第5回
WBS(Work Breakdown Structure)とはプロジェクト目標を達成し、必要な要素成果物を生成するために、プロジェクトチームが実行する作業を、要素成果物を主体に階層的に要素分解したものである。スコープが明確になる、作業を洗い出す、全体管理と作業計画が明確化される、プロジェクト実施時はWBSに則り実行するのみであるというメリットがある。WBSの作り方はまず、スコープを明確にする。その際には、トップダウンからのアプローチを行いバックキャスティングで行う。次に、大きな作業をグルーピング、そしてグルーピングした作業の相互関連を考える。データ収集をした後で分析する。データ分析した後でデータ収集しないように気を付ける。最後に漏れやダブりがないように各グループの作業を洗い出す。

## 第6回
WBSの演習を行った。私は情報処理技術者試験のクイズ大会についてのWBSを作成した。どういうものを準備すればよいかを抜けなく考えなければならないのでとても難しい作業だったが本番の流れをタイムスケジューリングしながら一通り想定して計画を立てるのでこのWBSさえ立てれば本番はこの通りにやるだけということを実感できた。普通の進行の流れだけでなくどのようなトラブルが起こり得るのか、またそれに対してどう対処するのか考えるのが難しかった。

## 第7回
コードは書くよりも読まれることの方が多い。ソフトウェア開発にあたり読みやすいコードを書くことは必須。コーディングには様々なルールがある。講義内ではPEP8を学んだ。PEP8には1行の長さを79文字以内にするや1レベルインデントするごとにスペースを4つ使うなどのルールがある。講義ではflake8を用いて演習を行った。

## 第8回
バージョン管理とは、ファイルを「誰が」、「いつ」、「どのように」変更したかを管理することである。これらの情報が管理されていれば、多数のメンバーとも共同でコード開発ができる。管理の型は集中管理型(Subversionなど)と分散管理型(gitなど)の2種類存在する。集中管理型は同時編集するとコンフリクトが発生しやすいことと同期に時間がかかるという特徴がある。分散管理型はリモートレポジトリへのアクセス頻度が低いことと障害に頑健であるという特徴がある。分散管理型のバージョン管理システムの一つであるgitについて紹介する。もともとはオープンソースソフトウェア管理のためのソフトウェアで変更履歴が残る、変更した箇所に戻ることができる、他人と共同編集できるといった特徴がある。ファイルの作成/変更/削除の記録をすることをコミットするという。gitが管理するプロジェクトのフォルダのことをレポジトリという。個々のプロジェクト実行環境であるローカルレポジトリと共有の管理場所であるリモートレポジトリがある。ワークツリーで変更したファイルを保存し、Gitディレクトリでコミットにより変更を登録する。ローカルレポジトリでコミットされた変更をリモートレポジトリへ反映させる。これがリモートレポジトリの流れである。ブランチは作業を枝分かれさせることができ、共同作業・並行作業が可能である。

## 第9回
ゲスト講師による講義を行った。

## 第10回
Learning git branchingによってgitの演習を行った。

## 第11回
githubとはリモートレポジトリのホスティングサービスの一つで、オープンソースソフトウェアの主要なポータルサイトである。ブラウザ上でVScode環境を構築できるCodespacesを用いてgithubの演習を行った。

## 第12回
Continuous Integration (CI)とは、コード変更を共有リポジトリに頻繁に統合するプロセスで、自動テストとビルドを定期的に実行しバグの早期発見と修正を可能にする。CIの自動化により開発のスムーズな進行を促進している。Continuous Delivery (CD)とは、コード変更をテスト環境や本番環境に自動的にデプロイするプロセスで、自動デプロイメントを組み込み、手動操作によるデプロイの必要性を排除する。CDにより、ユーザーフィードバックを迅速に反映可能である。CI/CDパイプラインは、ソース、ビルド、テスト、デプロイ、検証、モニタリングといったステップを経て行われる。

## 第13回
Github PagesはGithubにあるリモートレポジトリの内容をwebpageとして公開することができる。HP更改はCI/CDにより自動化されている。Jekyllを使用することでmarkdownファイルを自動でhtml化することができる。




